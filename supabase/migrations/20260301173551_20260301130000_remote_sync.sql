drop extension if exists "pg_net";
create sequence "public"."detailed_logs_id_seq";
create sequence "public"."feed_processing_batches_id_seq";
drop policy "Enable full access for admins" on "public"."content_book";
drop policy "Enable full access for admins and service role" on "public"."content_book_topics";
drop policy "Enable full access for admins" on "public"."content_post";
drop policy "Enable full access for admins and service role" on "public"."content_post_topics";
drop policy "Enable full access for admins" on "public"."content_site";
drop policy "Enable full access for admins" on "public"."content_tool";
drop policy "Enable full access for admins and service role" on "public"."content_tool_topics";
drop policy "Enable full access for admin users" on "public"."search_history";
drop policy "Enable insert for authenticated users" on "public"."search_history";
drop policy "Enable read access for users own searches" on "public"."search_history";
drop policy "Users can create their own profile" on "public"."user_profiles";
drop policy "Users can update their own profile" on "public"."user_profiles";
create table "public"."app_settings" (
    "key" text not null,
    "value" text not null,
    "description" text,
    "created_at" timestamp with time zone not null default now(),
    "updated_at" timestamp with time zone not null default now()
      );
alter table "public"."app_settings" enable row level security;
create table "public"."detailed_logs" (
    "id" bigint not null default nextval('public.detailed_logs_id_seq'::regclass),
    "timestamp" timestamp with time zone not null default now(),
    "function_name" text not null,
    "execution_id" text not null,
    "level" text not null,
    "message" text not null,
    "job_id" bigint,
    "step" text,
    "metadata" jsonb,
    "error" jsonb
      );
alter table "public"."detailed_logs" enable row level security;
create table "public"."edge_function_logs" (
    "id" bigint generated by default as identity not null,
    "function_name" character varying(100) not null,
    "execution_id" uuid not null default gen_random_uuid(),
    "job_id" bigint,
    "status" character varying(50) not null,
    "started_at" timestamp with time zone not null default now(),
    "completed_at" timestamp with time zone,
    "duration_ms" integer,
    "success" boolean,
    "error" text,
    "items_processed" integer default 0,
    "items_failed" integer default 0,
    "memory_used_mb" double precision,
    "context" jsonb default '{}'::jsonb
      );
alter table "public"."edge_function_logs" enable row level security;
create table "public"."edge_function_steps" (
    "id" bigint generated by default as identity not null,
    "log_id" bigint,
    "step_name" character varying(100) not null,
    "started_at" timestamp with time zone not null default now(),
    "completed_at" timestamp with time zone,
    "duration_ms" integer,
    "success" boolean,
    "message" text,
    "data" jsonb default '{}'::jsonb
      );
alter table "public"."edge_function_steps" enable row level security;
create table "public"."feed_processing_batches" (
    "id" bigint not null default nextval('public.feed_processing_batches_id_seq'::regclass),
    "job_id" bigint,
    "batch_number" integer not null,
    "status" text not null default 'pending'::text,
    "continuation" boolean not null default false,
    "previous_batch_id" bigint,
    "created_at" timestamp with time zone not null default now(),
    "started_at" timestamp with time zone,
    "completed_at" timestamp with time zone,
    "last_updated" timestamp with time zone,
    "items_processed" integer not null default 0,
    "error_count" integer not null default 0,
    "current_site" text,
    "error" text,
    "state" jsonb
      );
alter table "public"."feed_processing_batches" enable row level security;
create table "public"."feed_processing_events" (
    "id" bigint generated by default as identity not null,
    "job_id" bigint,
    "event_type" character varying(50) not null,
    "created_at" timestamp with time zone not null default now(),
    "payload" jsonb default '{}'::jsonb,
    "processed" boolean default false,
    "processed_at" timestamp with time zone,
    "batch_id" bigint
      );
alter table "public"."feed_processing_events" enable row level security;
alter table "public"."content_post" add column "bluesky_posted" boolean default false;
alter table "public"."content_post" add column "bluesky_posted_at" timestamp with time zone;
alter table "public"."feed_processing_jobs" add column "batch_size" integer default 10;
alter table "public"."feed_processing_jobs" add column "current_batch" integer default 0;
alter table "public"."feed_processing_jobs" add column "job_type" character varying(50) not null default 'feed_processing'::character varying;
alter table "public"."feed_processing_jobs" add column "last_processed_item_id" integer;
alter table "public"."feed_processing_jobs" add column "last_processed_site_id" integer;
alter table "public"."feed_processing_jobs" add column "metadata" jsonb default '{}'::jsonb;
alter table "public"."feed_processing_jobs" add column "total_batches" integer default 1;
alter table "public"."feed_processing_jobs" alter column "created_by" drop not null;
alter sequence "public"."detailed_logs_id_seq" owned by "public"."detailed_logs"."id";
alter sequence "public"."feed_processing_batches_id_seq" owned by "public"."feed_processing_batches"."id";
CREATE UNIQUE INDEX app_settings_pkey ON public.app_settings USING btree (key);
CREATE UNIQUE INDEX detailed_logs_pkey ON public.detailed_logs USING btree (id);
CREATE UNIQUE INDEX edge_function_logs_pkey ON public.edge_function_logs USING btree (id);
CREATE UNIQUE INDEX edge_function_steps_pkey ON public.edge_function_steps USING btree (id);
CREATE UNIQUE INDEX feed_processing_batches_pkey ON public.feed_processing_batches USING btree (id);
CREATE UNIQUE INDEX feed_processing_events_pkey ON public.feed_processing_events USING btree (id);
CREATE INDEX idx_batches_job_id ON public.feed_processing_batches USING btree (job_id);
CREATE INDEX idx_batches_status ON public.feed_processing_batches USING btree (status);
CREATE INDEX idx_content_book_topics_book_id ON public.content_book_topics USING btree (book_id);
CREATE INDEX idx_content_book_topics_topic_id ON public.content_book_topics USING btree (topic_id);
CREATE INDEX idx_content_post_indexed ON public.content_post USING btree (indexed) WHERE (indexed = false);
CREATE INDEX idx_content_post_link ON public.content_post USING btree (link);
CREATE INDEX idx_content_post_site_id ON public.content_post USING btree (site_id) WHERE (site_id IS NOT NULL);
CREATE INDEX idx_content_post_status_date_published ON public.content_post USING btree (status, date_published DESC) WHERE ((status)::text = 'published'::text);
CREATE INDEX idx_content_post_topics_post_id ON public.content_post_topics USING btree (post_id);
CREATE INDEX idx_content_post_topics_topic_id ON public.content_post_topics USING btree (topic_id);
CREATE INDEX idx_content_post_user_id ON public.content_post USING btree (user_id) WHERE (user_id IS NOT NULL);
CREATE INDEX idx_content_site_include_in_newsfeed ON public.content_site USING btree (include_in_newsfeed, feed_url) WHERE ((include_in_newsfeed = true) AND (feed_url IS NOT NULL));
CREATE INDEX idx_content_site_site_type_site_id ON public.content_site_site_type USING btree (site_id);
CREATE INDEX idx_content_site_site_type_sitetype_id ON public.content_site_site_type USING btree (sitetype_id);
CREATE INDEX idx_content_site_user_id ON public.content_site USING btree (user_id) WHERE (user_id IS NOT NULL);
CREATE INDEX idx_content_tool_topics_tool_id ON public.content_tool_topics USING btree (tool_id);
CREATE INDEX idx_content_tool_topics_topic_id ON public.content_tool_topics USING btree (topic_id);
CREATE INDEX idx_content_tool_user_id ON public.content_tool USING btree (user_id) WHERE (user_id IS NOT NULL);
CREATE INDEX idx_content_user_topics_topic_id ON public.content_user_topics USING btree (topic_id);
CREATE INDEX idx_content_user_topics_user_profile_id ON public.content_user_topics USING btree (user_profile_id);
CREATE INDEX idx_detailed_logs_execution_id ON public.detailed_logs USING btree (execution_id);
CREATE INDEX idx_detailed_logs_job_id ON public.detailed_logs USING btree (job_id);
CREATE INDEX idx_detailed_logs_level ON public.detailed_logs USING btree (level);
CREATE INDEX idx_edge_function_logs_job_id ON public.edge_function_logs USING btree (job_id) WHERE (job_id IS NOT NULL);
CREATE INDEX idx_edge_function_steps_log_id ON public.edge_function_steps USING btree (log_id) WHERE (log_id IS NOT NULL);
CREATE INDEX idx_feed_processing_batches_job_id ON public.feed_processing_batches USING btree (job_id) WHERE (job_id IS NOT NULL);
CREATE INDEX idx_feed_processing_batches_previous_batch_id ON public.feed_processing_batches USING btree (previous_batch_id) WHERE (previous_batch_id IS NOT NULL);
CREATE INDEX idx_feed_processing_batches_status ON public.feed_processing_batches USING btree (status);
CREATE INDEX idx_feed_processing_events_batch_id ON public.feed_processing_events USING btree (batch_id) WHERE (batch_id IS NOT NULL);
CREATE INDEX idx_feed_processing_events_job_id ON public.feed_processing_events USING btree (job_id) WHERE (job_id IS NOT NULL);
CREATE INDEX idx_feed_processing_jobs_status_created_at ON public.feed_processing_jobs USING btree (status, created_at DESC);
CREATE INDEX idx_search_history_user_id_created_at ON public.search_history USING btree (user_id, created_at DESC) WHERE (user_id IS NOT NULL);
alter table "public"."app_settings" add constraint "app_settings_pkey" PRIMARY KEY using index "app_settings_pkey";
alter table "public"."detailed_logs" add constraint "detailed_logs_pkey" PRIMARY KEY using index "detailed_logs_pkey";
alter table "public"."edge_function_logs" add constraint "edge_function_logs_pkey" PRIMARY KEY using index "edge_function_logs_pkey";
alter table "public"."edge_function_steps" add constraint "edge_function_steps_pkey" PRIMARY KEY using index "edge_function_steps_pkey";
alter table "public"."feed_processing_batches" add constraint "feed_processing_batches_pkey" PRIMARY KEY using index "feed_processing_batches_pkey";
alter table "public"."feed_processing_events" add constraint "feed_processing_events_pkey" PRIMARY KEY using index "feed_processing_events_pkey";
alter table "public"."detailed_logs" add constraint "detailed_logs_job_id_fkey" FOREIGN KEY (job_id) REFERENCES public.feed_processing_jobs(id) ON DELETE SET NULL not valid;
alter table "public"."detailed_logs" validate constraint "detailed_logs_job_id_fkey";
alter table "public"."edge_function_logs" add constraint "edge_function_logs_job_id_fkey" FOREIGN KEY (job_id) REFERENCES public.feed_processing_jobs(id) not valid;
alter table "public"."edge_function_logs" validate constraint "edge_function_logs_job_id_fkey";
alter table "public"."edge_function_steps" add constraint "edge_function_steps_log_id_fkey" FOREIGN KEY (log_id) REFERENCES public.edge_function_logs(id) ON DELETE CASCADE not valid;
alter table "public"."edge_function_steps" validate constraint "edge_function_steps_log_id_fkey";
alter table "public"."feed_processing_batches" add constraint "feed_processing_batches_job_id_fkey" FOREIGN KEY (job_id) REFERENCES public.feed_processing_jobs(id) ON DELETE CASCADE not valid;
alter table "public"."feed_processing_batches" validate constraint "feed_processing_batches_job_id_fkey";
alter table "public"."feed_processing_batches" add constraint "feed_processing_batches_previous_batch_id_fkey" FOREIGN KEY (previous_batch_id) REFERENCES public.feed_processing_batches(id) ON DELETE SET NULL not valid;
alter table "public"."feed_processing_batches" validate constraint "feed_processing_batches_previous_batch_id_fkey";
alter table "public"."feed_processing_events" add constraint "feed_processing_events_batch_id_fkey" FOREIGN KEY (batch_id) REFERENCES public.feed_processing_batches(id) ON DELETE SET NULL not valid;
alter table "public"."feed_processing_events" validate constraint "feed_processing_events_batch_id_fkey";
alter table "public"."feed_processing_events" add constraint "feed_processing_events_job_id_fkey" FOREIGN KEY (job_id) REFERENCES public.feed_processing_jobs(id) not valid;
alter table "public"."feed_processing_events" validate constraint "feed_processing_events_job_id_fkey";
set check_function_bodies = off;
create or replace view "public"."admin_activity_logs" as  SELECT l.id,
    l.function_name,
    l.execution_id,
    l.job_id,
    l.status,
    l.started_at,
    l.completed_at,
    l.duration_ms,
    l.success,
    l.error,
    l.items_processed,
    l.items_failed,
    j.total_sites,
    j.processed_sites,
    j.total_batches,
    j.current_batch,
    j.batch_size,
    j.current_site,
    count(s.id) AS total_steps,
    sum(
        CASE
            WHEN (s.success = true) THEN 1
            ELSE 0
        END) AS successful_steps
   FROM ((public.edge_function_logs l
     LEFT JOIN public.feed_processing_jobs j ON ((l.job_id = j.id)))
     LEFT JOIN public.edge_function_steps s ON ((s.log_id = l.id)))
  GROUP BY l.id, j.id
  ORDER BY l.started_at DESC;
CREATE OR REPLACE FUNCTION public.check_job_completion(job_id_param bigint)
 RETURNS boolean
 LANGUAGE plpgsql
 SET search_path TO 'public', 'pg_temp'
AS $function$
DECLARE
  all_completed BOOLEAN;
  total_batches INTEGER;
  completed_batches INTEGER;
BEGIN
  -- Count all batches and completed batches
  SELECT 
    COUNT(*) = SUM(CASE WHEN status = 'completed' THEN 1 ELSE 0 END),
    COUNT(*),
    SUM(CASE WHEN status = 'completed' THEN 1 ELSE 0 END)
  INTO 
    all_completed, total_batches, completed_batches
  FROM 
    feed_processing_batches
  WHERE 
    job_id = job_id_param;
  
  -- If all batches are completed, mark the job as completed
  IF all_completed AND total_batches > 0 THEN
    UPDATE feed_processing_jobs
    SET 
      status = 'completed',
      completed_at = NOW(),
      last_updated = NOW()
    WHERE 
      id = job_id_param AND status = 'processing';
    
    -- Log the completion
    INSERT INTO detailed_logs (
      timestamp,
      function_name,
      execution_id,
      level,
      message,
      job_id,
      metadata
    ) VALUES (
      NOW(),
      'job_completion_check',
      gen_random_uuid()::text,
      'info',
      'Job marked as completed',
      job_id_param,
      json_build_object(
        'total_batches', total_batches,
        'completed_batches', completed_batches
      )
    );
    
    -- Create a job completion event
    INSERT INTO feed_processing_events (
      job_id,
      event_type,
      created_at,
      payload,
      processed
    ) VALUES (
      job_id_param,
      'job_completed',
      NOW(),
      json_build_object(
        'completion_time', NOW()
      ),
      false
    );
    
    RETURN TRUE;
  END IF;
  
  RETURN FALSE;
END;
$function$;
CREATE OR REPLACE FUNCTION public.check_job_completion_trigger()
 RETURNS trigger
 LANGUAGE plpgsql
 SET search_path TO 'public', 'pg_temp'
AS $function$
BEGIN
  IF NEW.status = 'completed' AND OLD.status != 'completed' THEN
    PERFORM check_job_completion(NEW.job_id);
  END IF;
  RETURN NEW;
END;
$function$;
CREATE OR REPLACE FUNCTION public.cleanup_stalled_batches()
 RETURNS integer
 LANGUAGE plpgsql
 SET search_path TO 'public', 'pg_temp'
AS $function$
DECLARE
  updated_count INTEGER;
BEGIN
  -- Mark batches as failed if they've been processing for more than 30 minutes
  WITH updated AS (
    UPDATE feed_processing_batches
    SET 
      status = 'failed',
      error = 'Batch stalled (no updates for 30+ minutes)',
      last_updated = NOW()
    WHERE 
      status = 'processing'
      AND started_at < NOW() - INTERVAL '30 minutes'
    RETURNING id, job_id
  )
  SELECT COUNT(*) INTO updated_count FROM updated;
  
  -- Create a notification for each stalled batch
  IF updated_count > 0 THEN
    -- Log the cleanup action
    INSERT INTO detailed_logs (
      timestamp,
      function_name,
      execution_id,
      level,
      message,
      metadata
    ) VALUES (
      NOW(),
      'cleanup_function',
      gen_random_uuid()::text,
      'warning',
      'Cleaned up stalled batches',
      json_build_object('count', updated_count)
    );
  END IF;
  
  RETURN updated_count;
END;
$function$;
CREATE OR REPLACE FUNCTION public.is_admin_user()
 RETURNS boolean
 LANGUAGE sql
 STABLE
 SET search_path TO 'public', 'pg_temp'
AS $function$
  SELECT EXISTS (
    SELECT 1 
    FROM user_profiles 
    WHERE user_id = auth.uid() 
    AND is_admin = true
  );
$function$;
CREATE OR REPLACE FUNCTION public.notify_batch_ready()
 RETURNS trigger
 LANGUAGE plpgsql
 SET search_path TO 'public', 'pg_temp'
AS $function$
BEGIN
  -- Emit notification to any listening services
  PERFORM pg_notify(
    'feed_batch_ready',
    json_build_object(
      'job_id', NEW.job_id,
      'batch_id', NEW.id,
      'batch_number', NEW.batch_number
    )::text
  );
  
  -- Also log this in our detailed_logs table
  INSERT INTO detailed_logs (
    timestamp,
    function_name,
    execution_id,
    level,
    message,
    job_id,
    metadata
  ) VALUES (
    NOW(),
    'database_trigger',
    gen_random_uuid()::text,
    'info',
    'Batch ready notification sent',
    NEW.job_id,
    json_build_object(
      'batch_id', NEW.id,
      'batch_number', NEW.batch_number
    )
  );
  
  RETURN NEW;
END;
$function$;
grant delete on table "public"."app_settings" to "anon";
grant insert on table "public"."app_settings" to "anon";
grant references on table "public"."app_settings" to "anon";
grant select on table "public"."app_settings" to "anon";
grant trigger on table "public"."app_settings" to "anon";
grant truncate on table "public"."app_settings" to "anon";
grant update on table "public"."app_settings" to "anon";
grant delete on table "public"."app_settings" to "authenticated";
grant insert on table "public"."app_settings" to "authenticated";
grant references on table "public"."app_settings" to "authenticated";
grant select on table "public"."app_settings" to "authenticated";
grant trigger on table "public"."app_settings" to "authenticated";
grant truncate on table "public"."app_settings" to "authenticated";
grant update on table "public"."app_settings" to "authenticated";
grant delete on table "public"."app_settings" to "service_role";
grant insert on table "public"."app_settings" to "service_role";
grant references on table "public"."app_settings" to "service_role";
grant select on table "public"."app_settings" to "service_role";
grant trigger on table "public"."app_settings" to "service_role";
grant truncate on table "public"."app_settings" to "service_role";
grant update on table "public"."app_settings" to "service_role";
grant delete on table "public"."detailed_logs" to "anon";
grant insert on table "public"."detailed_logs" to "anon";
grant references on table "public"."detailed_logs" to "anon";
grant select on table "public"."detailed_logs" to "anon";
grant trigger on table "public"."detailed_logs" to "anon";
grant truncate on table "public"."detailed_logs" to "anon";
grant update on table "public"."detailed_logs" to "anon";
grant delete on table "public"."detailed_logs" to "authenticated";
grant insert on table "public"."detailed_logs" to "authenticated";
grant references on table "public"."detailed_logs" to "authenticated";
grant select on table "public"."detailed_logs" to "authenticated";
grant trigger on table "public"."detailed_logs" to "authenticated";
grant truncate on table "public"."detailed_logs" to "authenticated";
grant update on table "public"."detailed_logs" to "authenticated";
grant delete on table "public"."detailed_logs" to "service_role";
grant insert on table "public"."detailed_logs" to "service_role";
grant references on table "public"."detailed_logs" to "service_role";
grant select on table "public"."detailed_logs" to "service_role";
grant trigger on table "public"."detailed_logs" to "service_role";
grant truncate on table "public"."detailed_logs" to "service_role";
grant update on table "public"."detailed_logs" to "service_role";
grant delete on table "public"."edge_function_logs" to "anon";
grant insert on table "public"."edge_function_logs" to "anon";
grant references on table "public"."edge_function_logs" to "anon";
grant select on table "public"."edge_function_logs" to "anon";
grant trigger on table "public"."edge_function_logs" to "anon";
grant truncate on table "public"."edge_function_logs" to "anon";
grant update on table "public"."edge_function_logs" to "anon";
grant delete on table "public"."edge_function_logs" to "authenticated";
grant insert on table "public"."edge_function_logs" to "authenticated";
grant references on table "public"."edge_function_logs" to "authenticated";
grant select on table "public"."edge_function_logs" to "authenticated";
grant trigger on table "public"."edge_function_logs" to "authenticated";
grant truncate on table "public"."edge_function_logs" to "authenticated";
grant update on table "public"."edge_function_logs" to "authenticated";
grant delete on table "public"."edge_function_logs" to "service_role";
grant insert on table "public"."edge_function_logs" to "service_role";
grant references on table "public"."edge_function_logs" to "service_role";
grant select on table "public"."edge_function_logs" to "service_role";
grant trigger on table "public"."edge_function_logs" to "service_role";
grant truncate on table "public"."edge_function_logs" to "service_role";
grant update on table "public"."edge_function_logs" to "service_role";
grant delete on table "public"."edge_function_steps" to "anon";
grant insert on table "public"."edge_function_steps" to "anon";
grant references on table "public"."edge_function_steps" to "anon";
grant select on table "public"."edge_function_steps" to "anon";
grant trigger on table "public"."edge_function_steps" to "anon";
grant truncate on table "public"."edge_function_steps" to "anon";
grant update on table "public"."edge_function_steps" to "anon";
grant delete on table "public"."edge_function_steps" to "authenticated";
grant insert on table "public"."edge_function_steps" to "authenticated";
grant references on table "public"."edge_function_steps" to "authenticated";
grant select on table "public"."edge_function_steps" to "authenticated";
grant trigger on table "public"."edge_function_steps" to "authenticated";
grant truncate on table "public"."edge_function_steps" to "authenticated";
grant update on table "public"."edge_function_steps" to "authenticated";
grant delete on table "public"."edge_function_steps" to "service_role";
grant insert on table "public"."edge_function_steps" to "service_role";
grant references on table "public"."edge_function_steps" to "service_role";
grant select on table "public"."edge_function_steps" to "service_role";
grant trigger on table "public"."edge_function_steps" to "service_role";
grant truncate on table "public"."edge_function_steps" to "service_role";
grant update on table "public"."edge_function_steps" to "service_role";
grant delete on table "public"."feed_processing_batches" to "anon";
grant insert on table "public"."feed_processing_batches" to "anon";
grant references on table "public"."feed_processing_batches" to "anon";
grant select on table "public"."feed_processing_batches" to "anon";
grant trigger on table "public"."feed_processing_batches" to "anon";
grant truncate on table "public"."feed_processing_batches" to "anon";
grant update on table "public"."feed_processing_batches" to "anon";
grant delete on table "public"."feed_processing_batches" to "authenticated";
grant insert on table "public"."feed_processing_batches" to "authenticated";
grant references on table "public"."feed_processing_batches" to "authenticated";
grant select on table "public"."feed_processing_batches" to "authenticated";
grant trigger on table "public"."feed_processing_batches" to "authenticated";
grant truncate on table "public"."feed_processing_batches" to "authenticated";
grant update on table "public"."feed_processing_batches" to "authenticated";
grant delete on table "public"."feed_processing_batches" to "service_role";
grant insert on table "public"."feed_processing_batches" to "service_role";
grant references on table "public"."feed_processing_batches" to "service_role";
grant select on table "public"."feed_processing_batches" to "service_role";
grant trigger on table "public"."feed_processing_batches" to "service_role";
grant truncate on table "public"."feed_processing_batches" to "service_role";
grant update on table "public"."feed_processing_batches" to "service_role";
grant delete on table "public"."feed_processing_events" to "anon";
grant insert on table "public"."feed_processing_events" to "anon";
grant references on table "public"."feed_processing_events" to "anon";
grant select on table "public"."feed_processing_events" to "anon";
grant trigger on table "public"."feed_processing_events" to "anon";
grant truncate on table "public"."feed_processing_events" to "anon";
grant update on table "public"."feed_processing_events" to "anon";
grant delete on table "public"."feed_processing_events" to "authenticated";
grant insert on table "public"."feed_processing_events" to "authenticated";
grant references on table "public"."feed_processing_events" to "authenticated";
grant select on table "public"."feed_processing_events" to "authenticated";
grant trigger on table "public"."feed_processing_events" to "authenticated";
grant truncate on table "public"."feed_processing_events" to "authenticated";
grant update on table "public"."feed_processing_events" to "authenticated";
grant delete on table "public"."feed_processing_events" to "service_role";
grant insert on table "public"."feed_processing_events" to "service_role";
grant references on table "public"."feed_processing_events" to "service_role";
grant select on table "public"."feed_processing_events" to "service_role";
grant trigger on table "public"."feed_processing_events" to "service_role";
grant truncate on table "public"."feed_processing_events" to "service_role";
grant update on table "public"."feed_processing_events" to "service_role";
create policy "Users can manage their own posts"
  on "public"."content_post"
  as permissive
  for all
  to public
using ((user_id IN ( SELECT user_profiles.id
   FROM public.user_profiles
  WHERE (user_profiles.user_id = ( SELECT auth.uid() AS uid)))));
create policy "Users can manage their own sites"
  on "public"."content_site"
  as permissive
  for all
  to public
using ((user_id IN ( SELECT user_profiles.id
   FROM public.user_profiles
  WHERE (user_profiles.user_id = ( SELECT auth.uid() AS uid)))));
create policy "Users can manage their own tools"
  on "public"."content_tool"
  as permissive
  for all
  to public
using ((user_id IN ( SELECT user_profiles.id
   FROM public.user_profiles
  WHERE (user_profiles.user_id = ( SELECT auth.uid() AS uid)))));
create policy "Enable delete for own topics"
  on "public"."content_user_topics"
  as permissive
  for delete
  to public
using ((user_profile_id IN ( SELECT user_profiles.id
   FROM public.user_profiles
  WHERE (user_profiles.user_id = ( SELECT auth.uid() AS uid)))));
create policy "Enable insert for authenticated users"
  on "public"."content_user_topics"
  as permissive
  for insert
  to public
with check ((user_profile_id IN ( SELECT user_profiles.id
   FROM public.user_profiles
  WHERE (user_profiles.user_id = ( SELECT auth.uid() AS uid)))));
create policy "Enable select for own topics"
  on "public"."content_user_topics"
  as permissive
  for select
  to public
using ((user_profile_id IN ( SELECT user_profiles.id
   FROM public.user_profiles
  WHERE (user_profiles.user_id = ( SELECT auth.uid() AS uid)))));
create policy "Allow admin access"
  on "public"."detailed_logs"
  as permissive
  for all
  to public
using ((EXISTS ( SELECT 1
   FROM public.user_profiles
  WHERE ((user_profiles.user_id = auth.uid()) AND (user_profiles.is_admin = true)))));
create policy "Allow service role access"
  on "public"."detailed_logs"
  as permissive
  for all
  to public
using ((auth.role() = 'service_role'::text));
create policy "Allow full access to admins"
  on "public"."edge_function_logs"
  as permissive
  for all
  to public
using (( SELECT user_profiles.is_admin
   FROM public.user_profiles
  WHERE (user_profiles.user_id = auth.uid())));
create policy "Allow service role access"
  on "public"."edge_function_logs"
  as permissive
  for all
  to public
using ((auth.role() = 'service_role'::text));
create policy "Allow full access to admins"
  on "public"."edge_function_steps"
  as permissive
  for all
  to public
using (( SELECT user_profiles.is_admin
   FROM public.user_profiles
  WHERE (user_profiles.user_id = auth.uid())));
create policy "Allow service role access"
  on "public"."edge_function_steps"
  as permissive
  for all
  to public
using ((auth.role() = 'service_role'::text));
create policy "Allow admin access"
  on "public"."feed_processing_batches"
  as permissive
  for all
  to public
using ((EXISTS ( SELECT 1
   FROM public.user_profiles
  WHERE ((user_profiles.user_id = auth.uid()) AND (user_profiles.is_admin = true)))));
create policy "Allow service role access"
  on "public"."feed_processing_batches"
  as permissive
  for all
  to public
using ((auth.role() = 'service_role'::text));
create policy "Allow full access to admins"
  on "public"."feed_processing_events"
  as permissive
  for all
  to public
using (( SELECT user_profiles.is_admin
   FROM public.user_profiles
  WHERE (user_profiles.user_id = auth.uid())));
create policy "Allow service role access"
  on "public"."feed_processing_events"
  as permissive
  for all
  to public
using ((auth.role() = 'service_role'::text));
create policy "Users can view their own profile"
  on "public"."user_profiles"
  as permissive
  for select
  to public
using ((user_id = ( SELECT auth.uid() AS uid)));
create policy "Enable full access for admins"
  on "public"."content_book"
  as permissive
  for all
  to public
using ((EXISTS ( SELECT 1
   FROM public.user_profiles
  WHERE ((user_profiles.user_id = ( SELECT auth.uid() AS uid)) AND (user_profiles.is_admin = true)))));
create policy "Enable full access for admins and service role"
  on "public"."content_book_topics"
  as permissive
  for all
  to public
using ((((( SELECT auth.jwt() AS jwt) ->> 'role'::text) = 'service_role'::text) OR (EXISTS ( SELECT 1
   FROM public.user_profiles
  WHERE ((user_profiles.user_id = ( SELECT auth.uid() AS uid)) AND (user_profiles.is_admin = true))))));
create policy "Enable full access for admins"
  on "public"."content_post"
  as permissive
  for all
  to public
using ((EXISTS ( SELECT 1
   FROM public.user_profiles
  WHERE ((user_profiles.user_id = ( SELECT auth.uid() AS uid)) AND (user_profiles.is_admin = true)))));
create policy "Enable full access for admins and service role"
  on "public"."content_post_topics"
  as permissive
  for all
  to public
using ((((( SELECT auth.jwt() AS jwt) ->> 'role'::text) = 'service_role'::text) OR (EXISTS ( SELECT 1
   FROM public.user_profiles
  WHERE ((user_profiles.user_id = ( SELECT auth.uid() AS uid)) AND (user_profiles.is_admin = true))))));
create policy "Enable full access for admins"
  on "public"."content_site"
  as permissive
  for all
  to public
using ((EXISTS ( SELECT 1
   FROM public.user_profiles
  WHERE ((user_profiles.user_id = ( SELECT auth.uid() AS uid)) AND (user_profiles.is_admin = true)))));
create policy "Enable full access for admins"
  on "public"."content_tool"
  as permissive
  for all
  to public
using ((EXISTS ( SELECT 1
   FROM public.user_profiles
  WHERE ((user_profiles.user_id = ( SELECT auth.uid() AS uid)) AND (user_profiles.is_admin = true)))));
create policy "Enable full access for admins and service role"
  on "public"."content_tool_topics"
  as permissive
  for all
  to public
using ((((( SELECT auth.jwt() AS jwt) ->> 'role'::text) = 'service_role'::text) OR (EXISTS ( SELECT 1
   FROM public.user_profiles
  WHERE ((user_profiles.user_id = ( SELECT auth.uid() AS uid)) AND (user_profiles.is_admin = true))))));
create policy "Enable full access for admin users"
  on "public"."search_history"
  as permissive
  for all
  to public
using ((EXISTS ( SELECT 1
   FROM public.user_profiles
  WHERE ((user_profiles.user_id = ( SELECT auth.uid() AS uid)) AND (user_profiles.is_admin = true)))));
create policy "Enable insert for authenticated users"
  on "public"."search_history"
  as permissive
  for insert
  to public
with check (((( SELECT auth.uid() AS uid) IS NOT NULL) AND ((user_id = ( SELECT auth.uid() AS uid)) OR (user_id IS NULL))));
create policy "Enable read access for users own searches"
  on "public"."search_history"
  as permissive
  for select
  to public
using (((user_id = ( SELECT auth.uid() AS uid)) OR (user_id IS NULL) OR ((( SELECT auth.jwt() AS jwt) ->> 'role'::text) = 'service_role'::text)));
create policy "Users can create their own profile"
  on "public"."user_profiles"
  as permissive
  for insert
  to public
with check ((user_id = ( SELECT auth.uid() AS uid)));
create policy "Users can update their own profile"
  on "public"."user_profiles"
  as permissive
  for update
  to public
using ((user_id = ( SELECT auth.uid() AS uid)));
CREATE TRIGGER trigger_check_job_completion AFTER UPDATE ON public.feed_processing_batches FOR EACH ROW WHEN (((new.status = 'completed'::text) AND (old.status <> 'completed'::text))) EXECUTE FUNCTION public.check_job_completion_trigger();
CREATE TRIGGER trigger_notify_batch_ready AFTER INSERT ON public.feed_processing_batches FOR EACH ROW WHEN ((new.status = 'pending'::text)) EXECUTE FUNCTION public.notify_batch_ready();
CREATE TRIGGER objects_delete_delete_prefix AFTER DELETE ON storage.objects FOR EACH ROW EXECUTE FUNCTION storage.delete_prefix_hierarchy_trigger();
CREATE TRIGGER objects_insert_create_prefix BEFORE INSERT ON storage.objects FOR EACH ROW EXECUTE FUNCTION storage.objects_insert_prefix_trigger();
CREATE TRIGGER objects_update_create_prefix BEFORE UPDATE ON storage.objects FOR EACH ROW WHEN (((new.name <> old.name) OR (new.bucket_id <> old.bucket_id))) EXECUTE FUNCTION storage.objects_update_prefix_trigger();
CREATE TRIGGER prefixes_create_hierarchy BEFORE INSERT ON storage.prefixes FOR EACH ROW WHEN ((pg_trigger_depth() < 1)) EXECUTE FUNCTION storage.prefixes_insert_trigger();
CREATE TRIGGER prefixes_delete_hierarchy AFTER DELETE ON storage.prefixes FOR EACH ROW EXECUTE FUNCTION storage.delete_prefix_hierarchy_trigger();
